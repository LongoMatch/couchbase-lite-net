// 
//  ILiteCore.cs
// 
//  Copyright (c) 2018 Couchbase, Inc All rights reserved.
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//  http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
// 
using System;

using LiteCore.Interop;

namespace Couchbase.Lite.Interop
{
    internal static unsafe partial class Native
    {
        public static long c4_now() => Impl.c4_now();
        public static string c4error_getMessage(C4Error error) => Impl.c4error_getMessage(error);
        public static byte[] c4error_getDescription(C4Error error) => Impl.c4error_getDescription(error);
        public static string c4error_getDescriptionC(C4Error error, char[] buffer, ulong bufferSize) => Impl.c4error_getDescriptionC(error, buffer, bufferSize);
        public static C4Error c4error_make(C4ErrorDomain domain, int code, string message) => Impl.c4error_make(domain, code, message);
        public static bool c4error_mayBeTransient(C4Error err) => Impl.c4error_mayBeTransient(err);
        public static bool c4error_mayBeNetworkDependent(C4Error err) => Impl.c4error_mayBeNetworkDependent(err);
        public static void c4log_writeToCallback(C4LogLevel level, C4LogCallback callback, bool preformatted) => Impl.c4log_writeToCallback(level, callback, preformatted);
        public static bool c4log_writeToBinaryFile(C4LogLevel level, string path, C4Error* error) => Impl.c4log_writeToBinaryFile(level, path, error);
        public static C4LogLevel c4log_callbackLevel() => Impl.c4log_callbackLevel();
        public static void c4log_setCallbackLevel(C4LogLevel level) => Impl.c4log_setCallbackLevel(level);
        public static C4LogLevel c4log_binaryFileLevel() => Impl.c4log_binaryFileLevel();
        public static void c4log_setBinaryFileLevel(C4LogLevel level) => Impl.c4log_setBinaryFileLevel(level);
        public static string c4log_getDomainName(C4LogDomain* x) => Impl.c4log_getDomainName(x);
        public static C4LogLevel c4log_getLevel(C4LogDomain* x) => Impl.c4log_getLevel(x);
        public static void c4log_setLevel(C4LogDomain* c4Domain, C4LogLevel level) => Impl.c4log_setLevel(c4Domain, level);
        public static void c4slog(C4LogDomain* domain, C4LogLevel level, string msg) => Impl.c4slog(domain, level, msg);
        public static string c4_getBuildInfo() => Impl.c4_getBuildInfo();
        public static string c4_getVersion() => Impl.c4_getVersion();
        public static int c4_getObjectCount() => Impl.c4_getObjectCount();
        public static void c4_dumpInstances() => Impl.c4_dumpInstances();
        public static bool c4blob_keyFromString(string str, C4BlobKey* x) => Impl.c4blob_keyFromString(str, x);
        public static string c4blob_keyToString(C4BlobKey key) => Impl.c4blob_keyToString(key);
        public static C4BlobStore* c4db_getBlobStore(C4Database* db, C4Error* outError) => Impl.c4db_getBlobStore(db, outError);
        public static C4BlobStore* c4blob_openStore(string dirPath, C4DatabaseFlags flags, C4EncryptionKey* encryptionKey, C4Error* outError) => Impl.c4blob_openStore(dirPath, flags, encryptionKey, outError);
        public static void c4blob_freeStore(C4BlobStore* store) => Impl.c4blob_freeStore(store);
        public static bool c4blob_deleteStore(C4BlobStore* store, C4Error* outError) => Impl.c4blob_deleteStore(store, outError);
        public static long c4blob_getSize(C4BlobStore* store, C4BlobKey key) => Impl.c4blob_getSize(store, key);
        public static byte[] c4blob_getContents(C4BlobStore* store, C4BlobKey key, C4Error* outError) => Impl.c4blob_getContents(store, key, outError);
        public static string c4blob_getFilePath(C4BlobStore* store, C4BlobKey key, C4Error* outError) => Impl.c4blob_getFilePath(store, key, outError);
        public static C4BlobKey c4blob_computeKey(byte[] contents) => Impl.c4blob_computeKey(contents);
        public static bool c4blob_create(C4BlobStore* store, byte[] contents, C4BlobKey* expectedKey, C4BlobKey* outKey, C4Error* error) => Impl.c4blob_create(store, contents, expectedKey, outKey, error);
        public static bool c4blob_delete(C4BlobStore* store, C4BlobKey key, C4Error* outError) => Impl.c4blob_delete(store, key, outError);
        public static C4ReadStream* c4blob_openReadStream(C4BlobStore* store, C4BlobKey key, C4Error* outError) => Impl.c4blob_openReadStream(store, key, outError);
        public static ulong c4stream_read(C4ReadStream *stream, byte[] buffer, int count, C4Error *outError) => Impl.c4stream_read(stream, buffer, count, outError);
        public static long c4stream_getLength(C4ReadStream* stream, C4Error* outError) => Impl.c4stream_getLength(stream, outError);
        public static bool c4stream_seek(C4ReadStream* stream, ulong position, C4Error* outError) => Impl.c4stream_seek(stream, position, outError);
        public static void c4stream_close(C4ReadStream* stream) => Impl.c4stream_close(stream);
        public static C4WriteStream* c4blob_openWriteStream(C4BlobStore* store, C4Error* outError) => Impl.c4blob_openWriteStream(store, outError);
        public static bool c4stream_write(C4WriteStream* stream, byte[] bytes, ulong length, C4Error* outError) => Impl.c4stream_write(stream, bytes, length, outError);
        public static C4BlobKey c4stream_computeBlobKey(C4WriteStream* stream) => Impl.c4stream_computeBlobKey(stream);
        public static bool c4stream_install(C4WriteStream* stream, C4BlobKey* expectedKey, C4Error* outError) => Impl.c4stream_install(stream, expectedKey, outError);
        public static void c4stream_closeWriter(C4WriteStream* stream) => Impl.c4stream_closeWriter(stream);
        public static C4Database* c4db_open(string path, C4DatabaseConfig* config, C4Error* outError) => Impl.c4db_open(path, config, outError);
        public static C4Database* c4db_openAgain(C4Database* db, C4Error* outError) => Impl.c4db_openAgain(db, outError);
        public static bool c4db_copy(string sourcePath, string destinationPath, C4DatabaseConfig* config, C4Error* error) => Impl.c4db_copy(sourcePath, destinationPath, config, error);
        public static C4Database* c4db_retain(C4Database* db) => Impl.c4db_retain(db);
        public static void c4db_free(C4Database* database) => Impl.c4db_free(database);
        public static bool c4db_close(C4Database* database, C4Error* outError) => Impl.c4db_close(database, outError);
        public static bool c4db_delete(C4Database* database, C4Error* outError) => Impl.c4db_delete(database, outError);
        public static bool c4db_deleteAtPath(string dbPath, C4Error* outError) => Impl.c4db_deleteAtPath(dbPath, outError);
        public static bool c4db_rekey(C4Database* database, C4EncryptionKey* newKey, C4Error* outError) => Impl.c4db_rekey(database, newKey, outError);
        public static bool c4_shutdown(C4Error* outError) => Impl.c4_shutdown(outError);
        public static string c4db_getPath(C4Database* db) => Impl.c4db_getPath(db);
        public static C4DatabaseConfig* c4db_getConfig(C4Database* db) => Impl.c4db_getConfig(db);
        public static ulong c4db_getDocumentCount(C4Database* database) => Impl.c4db_getDocumentCount(database);
        public static ulong c4db_getLastSequence(C4Database* database) => Impl.c4db_getLastSequence(database);
        public static long c4db_nextDocExpiration(C4Database* database) => Impl.c4db_nextDocExpiration(database);
        public static long c4db_purgeExpiredDocs(C4Database* db, C4Error* outError) => Impl.c4db_purgeExpiredDocs(db, outError);
        public static uint c4db_getMaxRevTreeDepth(C4Database* database) => Impl.c4db_getMaxRevTreeDepth(database);
        public static void c4db_setMaxRevTreeDepth(C4Database* database, uint maxRevTreeDepth) => Impl.c4db_setMaxRevTreeDepth(database, maxRevTreeDepth);
        public static bool c4db_getUUIDs(C4Database* database, C4UUID* publicUUID, C4UUID* privateUUID, C4Error* outError) => Impl.c4db_getUUIDs(database, publicUUID, privateUUID, outError);
        public static bool c4db_compact(C4Database* database, C4Error* outError) => Impl.c4db_compact(database, outError);
        public static bool c4db_beginTransaction(C4Database* database, C4Error* outError) => Impl.c4db_beginTransaction(database, outError);
        public static bool c4db_endTransaction(C4Database* database, bool commit, C4Error* outError) => Impl.c4db_endTransaction(database, commit, outError);
        public static bool c4db_isInTransaction(C4Database* database) => Impl.c4db_isInTransaction(database);
        public static void c4raw_free(C4RawDocument* rawDoc) => Impl.c4raw_free(rawDoc);
        public static C4RawDocument* c4raw_get(C4Database* database, string storeName, string docID, C4Error* outError) => Impl.c4raw_get(database, storeName, docID, outError);
        public static bool c4raw_put(C4Database* database, string storeName, string key, string meta, string body, C4Error* outError) => Impl.c4raw_put(database, storeName, key, meta, body, outError);
        public static void c4enum_close(C4DocEnumerator* e) => Impl.c4enum_close(e);
        public static void c4enum_free(C4DocEnumerator* e) => Impl.c4enum_free(e);
        public static C4DocEnumerator* c4db_enumerateChanges(C4Database* database, ulong since, C4EnumeratorOptions* options, C4Error* outError) => Impl.c4db_enumerateChanges(database, since, options, outError);
        public static C4DocEnumerator* c4db_enumerateAllDocs(C4Database* database, C4EnumeratorOptions* options, C4Error* outError) => Impl.c4db_enumerateAllDocs(database, options, outError);
        public static bool c4enum_next(C4DocEnumerator* e, C4Error* outError) => Impl.c4enum_next(e, outError);
        public static C4Document* c4enum_getDocument(C4DocEnumerator* e, C4Error* outError) => Impl.c4enum_getDocument(e, outError);
        public static bool c4enum_getDocumentInfo(C4DocEnumerator* e, C4DocumentInfo* outInfo) => Impl.c4enum_getDocumentInfo(e, outInfo);
        public static FLDoc* c4doc_createFleeceDoc(C4Document* x) => Impl.c4doc_createFleeceDoc(x);
        public static bool c4doc_isOldMetaProperty(string prop) => Impl.c4doc_isOldMetaProperty(prop);
        public static bool c4doc_hasOldMetaProperties(FLDict* doc) => Impl.c4doc_hasOldMetaProperties(doc);
        public static byte[] c4doc_encodeStrippingOldMetaProperties(FLDict* doc, FLSharedKeys* sk, C4Error* outError) => Impl.c4doc_encodeStrippingOldMetaProperties(doc, sk, outError);
        public static bool c4doc_getDictBlobKey(FLDict* dict, C4BlobKey* outKey) => Impl.c4doc_getDictBlobKey(dict, outKey);
        public static bool c4doc_dictIsBlob(FLDict* dict, C4BlobKey* outKey) => Impl.c4doc_dictIsBlob(dict, outKey);
        public static bool c4doc_dictContainsBlobs(FLDict* dict) => Impl.c4doc_dictContainsBlobs(dict);
        public static bool c4doc_blobIsCompressible(FLDict* blobDict) => Impl.c4doc_blobIsCompressible(blobDict);
        public static string c4doc_bodyAsJSON(C4Document* doc, bool canonical, C4Error* outError) => Impl.c4doc_bodyAsJSON(doc, canonical, outError);
        public static FLEncoder* c4db_createFleeceEncoder(C4Database* db) => Impl.c4db_createFleeceEncoder(db);
        public static FLEncoder* c4db_getSharedFleeceEncoder(C4Database* db) => Impl.c4db_getSharedFleeceEncoder(db);
        public static byte[] c4db_encodeJSON(C4Database* db, string jsonData, C4Error* outError) => Impl.c4db_encodeJSON(db, jsonData, outError);
        public static FLSharedKeys* c4db_getFLSharedKeys(C4Database* db) => Impl.c4db_getFLSharedKeys(db);
        public static C4Document* c4doc_get(C4Database* database, string docID, bool mustExist, C4Error* outError) => Impl.c4doc_get(database, docID, mustExist, outError);
        public static C4Document* c4doc_getBySequence(C4Database* database, ulong sequence, C4Error* outError) => Impl.c4doc_getBySequence(database, sequence, outError);
        public static bool c4doc_save(C4Document* doc, uint maxRevTreeDepth, C4Error* outError) => Impl.c4doc_save(doc, maxRevTreeDepth, outError);
        public static void c4doc_free(C4Document* doc) => Impl.c4doc_free(doc);
        public static bool c4doc_selectRevision(C4Document* doc, string revID, bool withBody, C4Error* outError) => Impl.c4doc_selectRevision(doc, revID, withBody, outError);
        public static bool c4doc_selectCurrentRevision(C4Document* doc) => Impl.c4doc_selectCurrentRevision(doc);
        public static bool c4doc_loadRevisionBody(C4Document* doc, C4Error* outError) => Impl.c4doc_loadRevisionBody(doc, outError);
        public static string c4doc_detachRevisionBody(C4Document* doc) => Impl.c4doc_detachRevisionBody(doc);
        public static bool c4doc_hasRevisionBody(C4Document* doc) => Impl.c4doc_hasRevisionBody(doc);
        public static bool c4doc_selectParentRevision(C4Document* doc) => Impl.c4doc_selectParentRevision(doc);
        public static bool c4doc_selectNextRevision(C4Document* doc) => Impl.c4doc_selectNextRevision(doc);
        public static bool c4doc_selectNextLeafRevision(C4Document* doc, bool includeDeleted, bool withBody, C4Error* outError) => Impl.c4doc_selectNextLeafRevision(doc, includeDeleted, withBody, outError);
        public static bool c4doc_selectFirstPossibleAncestorOf(C4Document* doc, string revID) => Impl.c4doc_selectFirstPossibleAncestorOf(doc, revID);
        public static bool c4doc_selectNextPossibleAncestorOf(C4Document* doc, string revID) => Impl.c4doc_selectNextPossibleAncestorOf(doc, revID);
        public static bool c4doc_selectCommonAncestorRevision(C4Document* doc, string rev1ID, string rev2ID) => Impl.c4doc_selectCommonAncestorRevision(doc, rev1ID, rev2ID);
        public static uint c4db_getRemoteDBID(C4Database* db, string remoteAddress, bool canCreate, C4Error* outError) => Impl.c4db_getRemoteDBID(db, remoteAddress, canCreate, outError);
        public static byte[] c4db_getRemoteDBAddress(C4Database* db, uint remoteID) => Impl.c4db_getRemoteDBAddress(db, remoteID);
        public static byte[] c4doc_getRemoteAncestor(C4Document* doc, uint remoteDatabase) => Impl.c4doc_getRemoteAncestor(doc, remoteDatabase);
        public static bool c4doc_setRemoteAncestor(C4Document* doc, uint remoteDatabase, C4Error* error) => Impl.c4doc_setRemoteAncestor(doc, remoteDatabase, error);
        public static uint c4rev_getGeneration(string revID) => Impl.c4rev_getGeneration(revID);
        public static bool c4doc_removeRevisionBody(C4Document* doc) => Impl.c4doc_removeRevisionBody(doc);
        public static int c4doc_purgeRevision(C4Document* doc, string revID, C4Error* outError) => Impl.c4doc_purgeRevision(doc, revID, outError);
        public static bool c4doc_resolveConflict(C4Document* doc, string winningRevID, string losingRevID, byte[] mergedBody, C4RevisionFlags mergedFlags, C4Error* error) => Impl.c4doc_resolveConflict(doc, winningRevID, losingRevID, mergedBody, mergedFlags, error);
        public static bool c4db_purgeDoc(C4Database* database, string docID, C4Error* outError) => Impl.c4db_purgeDoc(database, docID, outError);
        public static bool c4doc_setExpiration(C4Database* db, string docId, long timestamp, C4Error* outError) => Impl.c4doc_setExpiration(db, docId, timestamp, outError);
        public static long c4doc_getExpiration(C4Database* db, string docId) => Impl.c4doc_getExpiration(db, docId);
        public static C4Document* c4doc_put(C4Database *database, C4DocPutRequest *request, ulong* outCommonAncestorIndex, C4Error *outError) => Impl.c4doc_put(database, request, outCommonAncestorIndex, outError);
        public static C4Document* c4doc_create(C4Database* db, string docID, byte[] body, C4RevisionFlags revisionFlags, C4Error* error) => Impl.c4doc_create(db, docID, body, revisionFlags, error);
        public static C4Document* c4doc_update(C4Document* doc, byte[] revisionBody, C4RevisionFlags revisionFlags, C4Error* error) => Impl.c4doc_update(doc, revisionBody, revisionFlags, error);
        public static C4DatabaseObserver* c4dbobs_create(C4Database* database, C4DatabaseObserverCallback callback, void* context) => Impl.c4dbobs_create(database, callback, context);
        public static uint c4dbobs_getChanges(C4DatabaseObserver* observer, C4DatabaseChange[] outChanges, uint maxChanges, bool* outExternal) => Impl.c4dbobs_getChanges(observer, outChanges, maxChanges, outExternal);
        public static void c4dbobs_releaseChanges(C4DatabaseChange[] changes, uint numChanges) => Impl.c4dbobs_releaseChanges(changes, numChanges);
        public static void c4dbobs_free(C4DatabaseObserver* observer) => Impl.c4dbobs_free(observer);
        public static C4DocumentObserver* c4docobs_create(C4Database* database, string docID, C4DocumentObserverCallback callback, void* context) => Impl.c4docobs_create(database, docID, callback, context);
        public static void c4docobs_free(C4DocumentObserver* observer) => Impl.c4docobs_free(observer);
        public static C4Query* c4query_new(C4Database* database, string expression, C4Error* error) => Impl.c4query_new(database, expression, error);
        public static void c4query_free(C4Query* query) => Impl.c4query_free(query);
        public static string c4query_explain(C4Query* query) => Impl.c4query_explain(query);
        public static uint c4query_columnCount(C4Query* query) => Impl.c4query_columnCount(query);
        public static FLSlice c4query_columnTitle(C4Query* query, uint column) => Impl.c4query_columnTitle(query, column);
        public static C4QueryEnumerator* c4query_run(C4Query* query, C4QueryOptions* options, string encodedParameters, C4Error* outError) => Impl.c4query_run(query, options, encodedParameters, outError);
        public static string c4query_fullTextMatched(C4Query* query, C4FullTextMatch* term, C4Error* outError) => Impl.c4query_fullTextMatched(query, term, outError);
        public static bool c4queryenum_next(C4QueryEnumerator* e, C4Error* outError) => Impl.c4queryenum_next(e, outError);
        public static long c4queryenum_getRowCount(C4QueryEnumerator* e, C4Error* outError) => Impl.c4queryenum_getRowCount(e, outError);
        public static bool c4queryenum_seek(C4QueryEnumerator* e, ulong rowIndex, C4Error* outError) => Impl.c4queryenum_seek(e, rowIndex, outError);
        public static C4QueryEnumerator* c4queryenum_refresh(C4QueryEnumerator* e, C4Error* outError) => Impl.c4queryenum_refresh(e, outError);
        public static void c4queryenum_close(C4QueryEnumerator* e) => Impl.c4queryenum_close(e);
        public static void c4queryenum_free(C4QueryEnumerator* e) => Impl.c4queryenum_free(e);
        public static bool c4db_createIndex(C4Database* database, string name, string expressionsJSON, C4IndexType indexType, C4IndexOptions* indexOptions, C4Error* outError) => Impl.c4db_createIndex(database, name, expressionsJSON, indexType, indexOptions, outError);
        public static bool c4db_deleteIndex(C4Database* database, string name, C4Error* outError) => Impl.c4db_deleteIndex(database, name, outError);
        public static byte[] c4db_getIndexes(C4Database* database, C4Error* outError) => Impl.c4db_getIndexes(database, outError);
        public static byte[] c4db_getIndexesInfo(C4Database* database, C4Error* outError) => Impl.c4db_getIndexesInfo(database, outError);
        public static bool c4repl_isValidDatabaseName(string dbName) => Impl.c4repl_isValidDatabaseName(dbName);
        public static bool c4address_fromURL(string url, C4Address* address, FLSlice* dbName) => Impl.c4address_fromURL(url, address, dbName);
        public static string c4address_toURL(C4Address address) => Impl.c4address_toURL(address);
        public static C4Replicator* c4repl_new(C4Database* db, C4Address remoteAddress, FLSlice remoteDatabaseName, C4Database* otherLocalDB, C4ReplicatorParameters @params, C4Error* outError) => Impl.c4repl_new(db, remoteAddress, remoteDatabaseName, otherLocalDB, @params, outError);
        public static C4Replicator* c4repl_newWithSocket(C4Database* db, C4Socket* openSocket, C4ReplicatorParameters @params, C4Error* outError) => Impl.c4repl_newWithSocket(db, openSocket, @params, outError);
        public static void c4repl_free(C4Replicator* repl) => Impl.c4repl_free(repl);
        public static void c4repl_stop(C4Replicator* repl) => Impl.c4repl_stop(repl);
        public static C4ReplicatorStatus c4repl_getStatus(C4Replicator* repl) => Impl.c4repl_getStatus(repl);
        public static FLSlice c4repl_getResponseHeaders(C4Replicator* repl) => Impl.c4repl_getResponseHeaders(repl);
        public static bool c4db_setCookie(C4Database* db, string setCookieHeader, string fromHost, string fromPath, C4Error* outError) => Impl.c4db_setCookie(db, setCookieHeader, fromHost, fromPath, outError);
        public static string c4db_getCookies(C4Database* db, C4Address request, C4Error* error) => Impl.c4db_getCookies(db, request, error);
        public static void c4db_clearCookies(C4Database* db) => Impl.c4db_clearCookies(db);
        public static void c4socket_registerFactory(C4SocketFactory factory) => Impl.c4socket_registerFactory(factory);
        public static void c4socket_gotHTTPResponse(C4Socket* socket, int httpStatus, FLSlice responseHeadersFleece) => Impl.c4socket_gotHTTPResponse(socket, httpStatus, responseHeadersFleece);
        public static void c4socket_opened(C4Socket* socket) => Impl.c4socket_opened(socket);
        public static void c4socket_closed(C4Socket* socket, C4Error errorIfAny) => Impl.c4socket_closed(socket, errorIfAny);
        public static void c4socket_closeRequested(C4Socket* socket, int status, string message) => Impl.c4socket_closeRequested(socket, status, message);
        public static void c4socket_completedWrite(C4Socket* socket, ulong byteCount) => Impl.c4socket_completedWrite(socket, byteCount);
        public static void c4socket_received(C4Socket* socket, byte[] data) => Impl.c4socket_received(socket, data);
        public static C4Socket* c4socket_fromNative(C4SocketFactory factory, void* nativeHandle, C4Address* address) => Impl.c4socket_fromNative(factory, nativeHandle, address);
        public static FLDoc* FLDoc_FromResultData(FLSliceResult data, FLTrust x, FLSharedKeys* shared, FLSlice externData) => Impl.FLDoc_FromResultData(data, x, shared, externData);
        public static FLDoc* FLDoc_FromJSON(byte[] json, FLError* outError) => Impl.FLDoc_FromJSON(json, outError);
        public static void FLDoc_Release(FLDoc* x) => Impl.FLDoc_Release(x);
        public static FLDoc* FLDoc_Retain(FLDoc* x) => Impl.FLDoc_Retain(x);
        public static byte[] FLDoc_GetData(FLDoc* x) => Impl.FLDoc_GetData(x);
        public static byte[] FLDoc_GetAllocedData(FLDoc* x) => Impl.FLDoc_GetAllocedData(x);
        public static FLValue* FLDoc_GetRoot(FLDoc* x) => Impl.FLDoc_GetRoot(x);
        public static FLSharedKeys* FLDoc_GetSharedKeys(FLDoc* x) => Impl.FLDoc_GetSharedKeys(x);
        public static FLDoc* FLValue_FindDoc(FLValue* value) => Impl.FLValue_FindDoc(value);
        public static FLValue* FLValue_FromData(byte[] data, FLTrust x) => Impl.FLValue_FromData(data, x);
        public static byte[] FLData_ConvertJSON(byte[] json, FLError* outError) => Impl.FLData_ConvertJSON(json, outError);
        public static string FLData_Dump(FLSlice data) => Impl.FLData_Dump(data);
        public static string FLValue_ToJSON(FLValue* value) => Impl.FLValue_ToJSON(value);
        public static string FLValue_ToJSON5(FLValue* v) => Impl.FLValue_ToJSON5(v);
        public static string FLValue_ToJSONX(FLValue* v, bool json5, bool canonicalForm) => Impl.FLValue_ToJSONX(v, json5, canonicalForm);
        public static string FLJSON5_ToJSON(string json5, FLError* error) => Impl.FLJSON5_ToJSON(json5, error);
        public static char* FLDump(FLValue* value) => Impl.FLDump(value);
        public static char* FLDumpData(byte[] data) => Impl.FLDumpData(data);
        public static FLValueType FLValue_GetType(FLValue* value) => Impl.FLValue_GetType(value);
        public static bool FLValue_IsInteger(FLValue* value) => Impl.FLValue_IsInteger(value);
        public static bool FLValue_IsUnsigned(FLValue* value) => Impl.FLValue_IsUnsigned(value);
        public static bool FLValue_IsDouble(FLValue* value) => Impl.FLValue_IsDouble(value);
        public static bool FLValue_AsBool(FLValue* value) => Impl.FLValue_AsBool(value);
        public static long FLValue_AsInt(FLValue* value) => Impl.FLValue_AsInt(value);
        public static ulong FLValue_AsUnsigned(FLValue* value) => Impl.FLValue_AsUnsigned(value);
        public static float FLValue_AsFloat(FLValue* value) => Impl.FLValue_AsFloat(value);
        public static double FLValue_AsDouble(FLValue* value) => Impl.FLValue_AsDouble(value);
        public static string FLValue_AsString(FLValue* value) => Impl.FLValue_AsString(value);
        public static long FLValue_AsTimestamp(FLValue* value) => Impl.FLValue_AsTimestamp(value);
        public static byte[] FLValue_AsData(FLValue* value) => Impl.FLValue_AsData(value);
        public static FLArray* FLValue_AsArray(FLValue* value) => Impl.FLValue_AsArray(value);
        public static FLDict* FLValue_AsDict(FLValue* value) => Impl.FLValue_AsDict(value);
        public static string FLValue_ToString(FLValue* value) => Impl.FLValue_ToString(value);
        public static bool FLValue_IsEqual(FLValue* v1, FLValue* v2) => Impl.FLValue_IsEqual(v1, v2);
        public static FLValue* FLValue_Retain(FLValue* value) => Impl.FLValue_Retain(value);
        public static void FLValue_Release(FLValue* value) => Impl.FLValue_Release(value);
        public static uint FLArray_Count(FLArray* array) => Impl.FLArray_Count(array);
        public static bool FLArray_IsEmpty(FLArray* array) => Impl.FLArray_IsEmpty(array);
        public static FLMutableArray FLArray_AsMutable(FLArray* array) => Impl.FLArray_AsMutable(array);
        public static FLValue* FLArray_Get(FLArray* array, uint index) => Impl.FLArray_Get(array, index);
        public static void FLArrayIterator_Begin(FLArray* array, FLArrayIterator* i) => Impl.FLArrayIterator_Begin(array, i);
        public static FLValue* FLArrayIterator_GetValue(FLArrayIterator* i) => Impl.FLArrayIterator_GetValue(i);
        public static FLValue* FLArrayIterator_GetValueAt(FLArrayIterator* i, uint offset) => Impl.FLArrayIterator_GetValueAt(i, offset);
        public static uint FLArrayIterator_GetCount(FLArrayIterator* i) => Impl.FLArrayIterator_GetCount(i);
        public static bool FLArrayIterator_Next(FLArrayIterator* i) => Impl.FLArrayIterator_Next(i);
        public static FLMutableArray FLArray_MutableCopy(FLArray* array) => Impl.FLArray_MutableCopy(array);
        public static FLMutableArray FLMutableArray_New() => Impl.FLMutableArray_New();
        public static FLArray* FLMutableArray_GetSource(FLMutableArray x) => Impl.FLMutableArray_GetSource(x);
        public static bool FLMutableArray_IsChanged(FLMutableArray x) => Impl.FLMutableArray_IsChanged(x);
        public static void FLMutableArray_AppendNull(FLMutableArray x) => Impl.FLMutableArray_AppendNull(x);
        public static void FLMutableArray_AppendBool(FLMutableArray x, bool b) => Impl.FLMutableArray_AppendBool(x, b);
        public static void FLMutableArray_AppendInt(FLMutableArray x, long l) => Impl.FLMutableArray_AppendInt(x, l);
        public static void FLMutableArray_AppendUInt(FLMutableArray x, ulong u) => Impl.FLMutableArray_AppendUInt(x, u);
        public static void FLMutableArray_AppendFloat(FLMutableArray x, float f) => Impl.FLMutableArray_AppendFloat(x, f);
        public static void FLMutableArray_AppendDouble(FLMutableArray x, double d) => Impl.FLMutableArray_AppendDouble(x, d);
        public static void FLMutableArray_AppendString(FLMutableArray x, string str) => Impl.FLMutableArray_AppendString(x, str);
        public static void FLMutableArray_AppendData(FLMutableArray x, byte[] slice) => Impl.FLMutableArray_AppendData(x, slice);
        public static void FLMutableArray_AppendValue(FLMutableArray x, FLValue* value) => Impl.FLMutableArray_AppendValue(x, value);
        public static void FLMutableArray_SetNull(FLMutableArray x, uint index) => Impl.FLMutableArray_SetNull(x, index);
        public static void FLMutableArray_SetBool(FLMutableArray x, uint index, bool b) => Impl.FLMutableArray_SetBool(x, index, b);
        public static void FLMutableArray_SetInt(FLMutableArray x, uint index, long l) => Impl.FLMutableArray_SetInt(x, index, l);
        public static void FLMutableArray_SetUInt(FLMutableArray x, uint index, ulong u) => Impl.FLMutableArray_SetUInt(x, index, u);
        public static void FLMutableArray_SetFloat(FLMutableArray x, uint index, float f) => Impl.FLMutableArray_SetFloat(x, index, f);
        public static void FLMutableArray_SetDouble(FLMutableArray x, uint index, double d) => Impl.FLMutableArray_SetDouble(x, index, d);
        public static void FLMutableArray_SetString(FLMutableArray x, uint index, string str) => Impl.FLMutableArray_SetString(x, index, str);
        public static void FLMutableArray_SetData(FLMutableArray x, uint index, byte[] slice) => Impl.FLMutableArray_SetData(x, index, slice);
        public static void FLMutableArray_SetValue(FLMutableArray x, uint index, FLValue* value) => Impl.FLMutableArray_SetValue(x, index, value);
        public static void FLMutableArray_Remove(FLMutableArray array, uint firstIndex, uint count) => Impl.FLMutableArray_Remove(array, firstIndex, count);
        public static void FLMutableArray_Resize(FLMutableArray array, uint size) => Impl.FLMutableArray_Resize(array, size);
        public static FLMutableArray FLMutableArray_GetMutableArray(FLMutableArray x, uint index) => Impl.FLMutableArray_GetMutableArray(x, index);
        public static FLMutableDict FLMutableArray_GetMutableDict(FLMutableArray x, uint index) => Impl.FLMutableArray_GetMutableDict(x, index);
        public static uint FLDict_Count(FLDict* dict) => Impl.FLDict_Count(dict);
        public static bool FLDict_IsEmpty(FLDict* dict) => Impl.FLDict_IsEmpty(dict);
        public static FLMutableDict FLDict_AsMutable(FLDict* dict) => Impl.FLDict_AsMutable(dict);
        public static FLValue* FLDict_Get(FLDict* dict, byte[] keyString) => Impl.FLDict_Get(dict, keyString);
        public static void FLDictIterator_Begin(FLDict* dict, FLDictIterator* i) => Impl.FLDictIterator_Begin(dict, i);
        public static FLValue* FLDictIterator_GetKey(FLDictIterator* i) => Impl.FLDictIterator_GetKey(i);
        public static string FLDictIterator_GetKeyString(FLDictIterator* i) => Impl.FLDictIterator_GetKeyString(i);
        public static FLValue* FLDictIterator_GetValue(FLDictIterator* i) => Impl.FLDictIterator_GetValue(i);
        public static uint FLDictIterator_GetCount(FLDictIterator* i) => Impl.FLDictIterator_GetCount(i);
        public static bool FLDictIterator_Next(FLDictIterator* i) => Impl.FLDictIterator_Next(i);
        public static void FLDictIterator_End(FLDictIterator* i) => Impl.FLDictIterator_End(i);
        public static FLDictKey FLDictKey_Init(string str) => Impl.FLDictKey_Init(str);
        public static string FLDictKey_GetString(FLDictKey* dictKey) => Impl.FLDictKey_GetString(dictKey);
        public static FLValue* FLDict_GetWithKey(FLDict* dict, FLDictKey* dictKey) => Impl.FLDict_GetWithKey(dict, dictKey);
        public static FLMutableDict FLDict_MutableCopy(FLDict* source) => Impl.FLDict_MutableCopy(source);
        public static FLMutableDict FLMutableDict_New() => Impl.FLMutableDict_New();
        public static FLDict* FLMutableDict_GetSource(FLMutableDict x) => Impl.FLMutableDict_GetSource(x);
        public static bool FLMutableDict_IsChanged(FLMutableDict x) => Impl.FLMutableDict_IsChanged(x);
        public static void FLMutableDict_SetNull(FLMutableDict x, string key) => Impl.FLMutableDict_SetNull(x, key);
        public static void FLMutableDict_SetBool(FLMutableDict x, string key, bool b) => Impl.FLMutableDict_SetBool(x, key, b);
        public static void FLMutableDict_SetInt(FLMutableDict x, string key, long l) => Impl.FLMutableDict_SetInt(x, key, l);
        public static void FLMutableDict_SetUInt(FLMutableDict x, string key, ulong u) => Impl.FLMutableDict_SetUInt(x, key, u);
        public static void FLMutableDict_SetFloat(FLMutableDict x, string key, float f) => Impl.FLMutableDict_SetFloat(x, key, f);
        public static void FLMutableDict_SetDouble(FLMutableDict x, string key, double d) => Impl.FLMutableDict_SetDouble(x, key, d);
        public static void FLMutableDict_SetString(FLMutableDict x, string key, string str) => Impl.FLMutableDict_SetString(x, key, str);
        public static void FLMutableDict_SetData(FLMutableDict x, string key, byte[] slice) => Impl.FLMutableDict_SetData(x, key, slice);
        public static void FLMutableDict_SetValue(FLMutableDict x, string key, FLValue* value) => Impl.FLMutableDict_SetValue(x, key, value);
        public static void FLMutableDict_Remove(FLMutableDict x, string key) => Impl.FLMutableDict_Remove(x, key);
        public static void FLMutableDict_RemoveAll(FLMutableDict x) => Impl.FLMutableDict_RemoveAll(x);
        public static FLMutableArray FLMutableDict_GetMutableArray(FLMutableDict x, string key) => Impl.FLMutableDict_GetMutableArray(x, key);
        public static FLMutableDict FLMutableDict_GetMutableDict(FLMutableDict x, string key) => Impl.FLMutableDict_GetMutableDict(x, key);
        public static FLDeepIterator* FLDeepIterator_New(FLValue* value) => Impl.FLDeepIterator_New(value);
        public static void FLDeepIterator_Free(FLDeepIterator* x) => Impl.FLDeepIterator_Free(x);
        public static FLValue* FLDeepIterator_GetValue(FLDeepIterator* x) => Impl.FLDeepIterator_GetValue(x);
        public static byte[] FLDeepIterator_GetKey(FLDeepIterator* x) => Impl.FLDeepIterator_GetKey(x);
        public static uint FLDeepIterator_GetIndex(FLDeepIterator* x) => Impl.FLDeepIterator_GetIndex(x);
        public static UIntPtr FLDeepIterator_GetDepth(FLDeepIterator* x) => Impl.FLDeepIterator_GetDepth(x);
        public static void FLDeepIterator_SkipChildren(FLDeepIterator* x) => Impl.FLDeepIterator_SkipChildren(x);
        public static bool FLDeepIterator_Next(FLDeepIterator* x) => Impl.FLDeepIterator_Next(x);
        public static void FLDeepIterator_GetPath(FLDeepIterator* x, FLPathComponent** outPath, UIntPtr* outDepth) => Impl.FLDeepIterator_GetPath(x, outPath, outDepth);
        public static byte[] FLDeepIterator_GetPathString(FLDeepIterator* x) => Impl.FLDeepIterator_GetPathString(x);
        public static byte[] FLDeepIterator_GetJSONPointer(FLDeepIterator* x) => Impl.FLDeepIterator_GetJSONPointer(x);
        public static FLKeyPath* FLKeyPath_New(byte[] specifier, FLError* error) => Impl.FLKeyPath_New(specifier, error);
        public static void FLKeyPath_Free(FLKeyPath* keyPath) => Impl.FLKeyPath_Free(keyPath);
        public static FLValue* FLKeyPath_Eval(FLKeyPath* keyPath, FLValue* root) => Impl.FLKeyPath_Eval(keyPath, root);
        public static FLValue* FLKeyPath_EvalOnce(byte[] specifier, FLValue* root, FLError* error) => Impl.FLKeyPath_EvalOnce(specifier, root, error);
        public static FLSharedKeys* FLSharedKeys_Create() => Impl.FLSharedKeys_Create();
        public static FLSharedKeys* FLSharedKeys_Retain(FLSharedKeys* shared) => Impl.FLSharedKeys_Retain(shared);
        public static void FLSharedKeys_Release(FLSharedKeys* shared) => Impl.FLSharedKeys_Release(shared);
        public static FLSharedKeys* FLSharedKeys_CreateFromStateData(byte[] slice) => Impl.FLSharedKeys_CreateFromStateData(slice);
        public static byte[] FLSharedKeys_GetStateData(FLSharedKeys* shared) => Impl.FLSharedKeys_GetStateData(shared);
        public static int FLSharedKeys_Encode(FLSharedKeys* shared, string str, bool add) => Impl.FLSharedKeys_Encode(shared, str, add);
        public static string FLSharedKeys_Decode(FLSharedKeys* shared, int key) => Impl.FLSharedKeys_Decode(shared, key);
        public static FLEncoder* FLEncoder_New() => Impl.FLEncoder_New();
        public static FLEncoder* FLEncoder_NewWithOptions(FLEncoderFormat format, ulong reserveSize, bool uniqueStrings) => Impl.FLEncoder_NewWithOptions(format, reserveSize, uniqueStrings);
        public static void FLEncoder_Free(FLEncoder* encoder) => Impl.FLEncoder_Free(encoder);
        public static void FLEncoder_SetSharedKeys(FLEncoder* encoder, FLSharedKeys* shared) => Impl.FLEncoder_SetSharedKeys(encoder, shared);
        public static void FLEncoder_SetExtraInfo(FLEncoder* encoder, void* info) => Impl.FLEncoder_SetExtraInfo(encoder, info);
        public static void* FLEncoder_GetExtraInfo(FLEncoder* encoder) => Impl.FLEncoder_GetExtraInfo(encoder);
        public static void FLEncoder_Amend(FLEncoder* e, byte[] @base, bool reuseStrings, bool externPointers) => Impl.FLEncoder_Amend(e, @base, reuseStrings, externPointers);
        public static byte[] FLEncoder_GetBase(FLEncoder* encoder) => Impl.FLEncoder_GetBase(encoder);
        public static void FLEncoder_SuppressTrailer(FLEncoder* encoder) => Impl.FLEncoder_SuppressTrailer(encoder);
        public static void FLEncoder_Reset(FLEncoder* encoder) => Impl.FLEncoder_Reset(encoder);
        public static UIntPtr FLEncoder_BytesWritten(FLEncoder* encoder) => Impl.FLEncoder_BytesWritten(encoder);
        public static UIntPtr FLEncoder_GetNextWritePos(FLEncoder* encoder) => Impl.FLEncoder_GetNextWritePos(encoder);
        public static bool FLEncoder_WriteNull(FLEncoder* encoder) => Impl.FLEncoder_WriteNull(encoder);
        public static bool FLEncoder_WriteBool(FLEncoder* encoder, bool b) => Impl.FLEncoder_WriteBool(encoder, b);
        public static bool FLEncoder_WriteInt(FLEncoder* encoder, long l) => Impl.FLEncoder_WriteInt(encoder, l);
        public static bool FLEncoder_WriteUInt(FLEncoder* encoder, ulong u) => Impl.FLEncoder_WriteUInt(encoder, u);
        public static bool FLEncoder_WriteFloat(FLEncoder* encoder, float f) => Impl.FLEncoder_WriteFloat(encoder, f);
        public static bool FLEncoder_WriteDouble(FLEncoder* encoder, double d) => Impl.FLEncoder_WriteDouble(encoder, d);
        public static bool FLEncoder_WriteString(FLEncoder* encoder, string str) => Impl.FLEncoder_WriteString(encoder, str);
        public static bool FLEncoder_WriteDateString(FLEncoder* encoder, long ts, bool asUTC) => Impl.FLEncoder_WriteDateString(encoder, ts, asUTC);
        public static bool FLEncoder_WriteData(FLEncoder* encoder, byte[] slice) => Impl.FLEncoder_WriteData(encoder, slice);
        public static bool FLEncoder_WriteRaw(FLEncoder* encoder, byte[] slice) => Impl.FLEncoder_WriteRaw(encoder, slice);
        public static bool FLEncoder_BeginArray(FLEncoder* encoder, ulong reserveCount) => Impl.FLEncoder_BeginArray(encoder, reserveCount);
        public static bool FLEncoder_EndArray(FLEncoder* encoder) => Impl.FLEncoder_EndArray(encoder);
        public static bool FLEncoder_BeginDict(FLEncoder* encoder, ulong reserveCount) => Impl.FLEncoder_BeginDict(encoder, reserveCount);
        public static bool FLEncoder_WriteKey(FLEncoder* encoder, string str) => Impl.FLEncoder_WriteKey(encoder, str);
        public static bool FLEncoder_WriteKeyValue(FLEncoder* encoder, FLValue* value) => Impl.FLEncoder_WriteKeyValue(encoder, value);
        public static bool FLEncoder_EndDict(FLEncoder* encoder) => Impl.FLEncoder_EndDict(encoder);
        public static bool FLEncoder_WriteValue(FLEncoder* encoder, FLValue* value) => Impl.FLEncoder_WriteValue(encoder, value);
        public static bool FLEncoder_ConvertJSON(FLEncoder* encoder, byte[] json) => Impl.FLEncoder_ConvertJSON(encoder, json);
        public static UIntPtr FLEncoder_FinishItem(FLEncoder* encoder) => Impl.FLEncoder_FinishItem(encoder);
        public static FLDoc* FLEncoder_FinishDoc(FLEncoder* encoder, FLError* outError) => Impl.FLEncoder_FinishDoc(encoder, outError);
        public static byte[] FLEncoder_Finish(FLEncoder* e, FLError* outError) => Impl.FLEncoder_Finish(e, outError);
        public static FLError FLEncoder_GetError(FLEncoder* encoder) => Impl.FLEncoder_GetError(encoder);
        public static string FLEncoder_GetErrorMessage(FLEncoder* encoder) => Impl.FLEncoder_GetErrorMessage(encoder);
        public static byte[] FLCreateJSONDelta(FLValue* old, FLValue* nuu) => Impl.FLCreateJSONDelta(old, nuu);
        public static bool FLEncodeJSONDelta(FLValue* old, FLValue* nuu, FLEncoder* jsonEncoder) => Impl.FLEncodeJSONDelta(old, nuu, jsonEncoder);
        public static byte[] FLApplyJSONDelta(FLValue* old, byte[] jsonDelta, FLError* error) => Impl.FLApplyJSONDelta(old, jsonDelta, error);
        public static bool FLEncodeApplyingJSONDelta(FLValue* old, FLValue* jsonDelta, FLEncoder* encoder) => Impl.FLEncodeApplyingJSONDelta(old, jsonDelta, encoder);
        public static bool FLSlice_Equal(FLSlice a, FLSlice b) => Impl.FLSlice_Equal(a, b);
        public static int FLSlice_Compare(FLSlice left, FLSlice right) => Impl.FLSlice_Compare(left, right);
        public static FLSliceResult FLSliceResult_Retain(FLSliceResult slice) => Impl.FLSliceResult_Retain(slice);
        public static void FLSliceResult_Release(FLSliceResult slice) => Impl.FLSliceResult_Release(slice);
        public static FLSliceResult FLSlice_Copy(FLSlice slice) => Impl.FLSlice_Copy(slice);
    }

    internal static unsafe partial class NativeRaw
    {
        public static FLSliceResult c4error_getMessage(C4Error error) => Impl.c4error_getMessage(error);
        public static FLSliceResult c4error_getDescription(C4Error error) => Impl.c4error_getDescription(error);
        public static byte* c4error_getDescriptionC(C4Error error, char[] buffer, UIntPtr bufferSize) => Impl.c4error_getDescriptionC(error, buffer, bufferSize);
        public static C4Error c4error_make(C4ErrorDomain domain, int code, FLSlice message) => Impl.c4error_make(domain, code, message);
        public static bool c4log_writeToBinaryFile(C4LogLevel level, FLSlice path, C4Error* error) => Impl.c4log_writeToBinaryFile(level, path, error);
        public static byte* c4log_getDomainName(C4LogDomain* x) => Impl.c4log_getDomainName(x);
        public static void c4slog(C4LogDomain* domain, C4LogLevel level, FLSlice msg) => Impl.c4slog(domain, level, msg);
        public static FLSliceResult c4_getBuildInfo() => Impl.c4_getBuildInfo();
        public static FLSliceResult c4_getVersion() => Impl.c4_getVersion();
        public static bool c4blob_keyFromString(FLSlice str, C4BlobKey* x) => Impl.c4blob_keyFromString(str, x);
        public static FLSliceResult c4blob_keyToString(C4BlobKey key) => Impl.c4blob_keyToString(key);
        public static C4BlobStore* c4blob_openStore(FLSlice dirPath, C4DatabaseFlags flags, C4EncryptionKey* encryptionKey, C4Error* outError) => Impl.c4blob_openStore(dirPath, flags, encryptionKey, outError);
        public static FLSliceResult c4blob_getContents(C4BlobStore* store, C4BlobKey key, C4Error* outError) => Impl.c4blob_getContents(store, key, outError);
        public static FLSliceResult c4blob_getFilePath(C4BlobStore* store, C4BlobKey key, C4Error* outError) => Impl.c4blob_getFilePath(store, key, outError);
        public static C4BlobKey c4blob_computeKey(FLSlice contents) => Impl.c4blob_computeKey(contents);
        public static bool c4blob_create(C4BlobStore* store, FLSlice contents, C4BlobKey* expectedKey, C4BlobKey* outKey, C4Error* error) => Impl.c4blob_create(store, contents, expectedKey, outKey, error);
        public static UIntPtr c4stream_read(C4ReadStream* stream, byte[] buffer, UIntPtr maxBytesToRead, C4Error* outError) => Impl.c4stream_read(stream, buffer, maxBytesToRead, outError);
        public static bool c4stream_write(C4WriteStream* stream, byte[] bytes, UIntPtr length, C4Error* outError) => Impl.c4stream_write(stream, bytes, length, outError);
        public static C4Database* c4db_open(FLSlice path, C4DatabaseConfig* config, C4Error* outError) => Impl.c4db_open(path, config, outError);
        public static bool c4db_copy(FLSlice sourcePath, FLSlice destinationPath, C4DatabaseConfig* config, C4Error* error) => Impl.c4db_copy(sourcePath, destinationPath, config, error);
        public static bool c4db_deleteAtPath(FLSlice dbPath, C4Error* outError) => Impl.c4db_deleteAtPath(dbPath, outError);
        public static FLSliceResult c4db_getPath(C4Database* db) => Impl.c4db_getPath(db);
        public static C4RawDocument* c4raw_get(C4Database* database, FLSlice storeName, FLSlice docID, C4Error* outError) => Impl.c4raw_get(database, storeName, docID, outError);
        public static bool c4raw_put(C4Database* database, FLSlice storeName, FLSlice key, FLSlice meta, FLSlice body, C4Error* outError) => Impl.c4raw_put(database, storeName, key, meta, body, outError);
        public static bool c4doc_isOldMetaProperty(FLSlice prop) => Impl.c4doc_isOldMetaProperty(prop);
        public static FLSliceResult c4doc_encodeStrippingOldMetaProperties(FLDict* doc, FLSharedKeys* sk, C4Error* outError) => Impl.c4doc_encodeStrippingOldMetaProperties(doc, sk, outError);
        public static FLSliceResult c4doc_bodyAsJSON(C4Document* doc, bool canonical, C4Error* outError) => Impl.c4doc_bodyAsJSON(doc, canonical, outError);
        public static FLSliceResult c4db_encodeJSON(C4Database* db, FLSlice jsonData, C4Error* outError) => Impl.c4db_encodeJSON(db, jsonData, outError);
        public static C4Document* c4doc_get(C4Database* database, FLSlice docID, bool mustExist, C4Error* outError) => Impl.c4doc_get(database, docID, mustExist, outError);
        public static bool c4doc_selectRevision(C4Document* doc, FLSlice revID, bool withBody, C4Error* outError) => Impl.c4doc_selectRevision(doc, revID, withBody, outError);
        public static FLSliceResult c4doc_detachRevisionBody(C4Document* doc) => Impl.c4doc_detachRevisionBody(doc);
        public static bool c4doc_selectFirstPossibleAncestorOf(C4Document* doc, FLSlice revID) => Impl.c4doc_selectFirstPossibleAncestorOf(doc, revID);
        public static bool c4doc_selectNextPossibleAncestorOf(C4Document* doc, FLSlice revID) => Impl.c4doc_selectNextPossibleAncestorOf(doc, revID);
        public static bool c4doc_selectCommonAncestorRevision(C4Document* doc, FLSlice rev1ID, FLSlice rev2ID) => Impl.c4doc_selectCommonAncestorRevision(doc, rev1ID, rev2ID);
        public static uint c4db_getRemoteDBID(C4Database* db, FLSlice remoteAddress, bool canCreate, C4Error* outError) => Impl.c4db_getRemoteDBID(db, remoteAddress, canCreate, outError);
        public static FLSliceResult c4db_getRemoteDBAddress(C4Database* db, uint remoteID) => Impl.c4db_getRemoteDBAddress(db, remoteID);
        public static FLSliceResult c4doc_getRemoteAncestor(C4Document* doc, uint remoteDatabase) => Impl.c4doc_getRemoteAncestor(doc, remoteDatabase);
        public static uint c4rev_getGeneration(FLSlice revID) => Impl.c4rev_getGeneration(revID);
        public static int c4doc_purgeRevision(C4Document* doc, FLSlice revID, C4Error* outError) => Impl.c4doc_purgeRevision(doc, revID, outError);
        public static bool c4doc_resolveConflict(C4Document* doc, FLSlice winningRevID, FLSlice losingRevID, FLSlice mergedBody, C4RevisionFlags mergedFlags, C4Error* error) => Impl.c4doc_resolveConflict(doc, winningRevID, losingRevID, mergedBody, mergedFlags, error);
        public static bool c4db_purgeDoc(C4Database* database, FLSlice docID, C4Error* outError) => Impl.c4db_purgeDoc(database, docID, outError);
        public static bool c4doc_setExpiration(C4Database* db, FLSlice docId, long timestamp, C4Error* outError) => Impl.c4doc_setExpiration(db, docId, timestamp, outError);
        public static long c4doc_getExpiration(C4Database* db, FLSlice docId) => Impl.c4doc_getExpiration(db, docId);
        public static C4Document* c4doc_put(C4Database* database, C4DocPutRequest* request, UIntPtr* outCommonAncestorIndex, C4Error* outError) => Impl.c4doc_put(database, request, outCommonAncestorIndex, outError);
        public static C4Document* c4doc_create(C4Database* db, FLSlice docID, FLSlice body, C4RevisionFlags revisionFlags, C4Error* error) => Impl.c4doc_create(db, docID, body, revisionFlags, error);
        public static C4Document* c4doc_update(C4Document* doc, FLSlice revisionBody, C4RevisionFlags revisionFlags, C4Error* error) => Impl.c4doc_update(doc, revisionBody, revisionFlags, error);
        public static C4DocumentObserver* c4docobs_create(C4Database* database, FLSlice docID, C4DocumentObserverCallback callback, void* context) => Impl.c4docobs_create(database, docID, callback, context);
        public static C4Query* c4query_new(C4Database* database, FLSlice expression, C4Error* error) => Impl.c4query_new(database, expression, error);
        public static FLSliceResult c4query_explain(C4Query* query) => Impl.c4query_explain(query);
        public static C4QueryEnumerator* c4query_run(C4Query* query, C4QueryOptions* options, FLSlice encodedParameters, C4Error* outError) => Impl.c4query_run(query, options, encodedParameters, outError);
        public static FLSliceResult c4query_fullTextMatched(C4Query* query, C4FullTextMatch* term, C4Error* outError) => Impl.c4query_fullTextMatched(query, term, outError);
        public static bool c4db_createIndex(C4Database* database, FLSlice name, FLSlice expressionsJSON, C4IndexType indexType, C4IndexOptions* indexOptions, C4Error* outError) => Impl.c4db_createIndex(database, name, expressionsJSON, indexType, indexOptions, outError);
        public static bool c4db_deleteIndex(C4Database* database, FLSlice name, C4Error* outError) => Impl.c4db_deleteIndex(database, name, outError);
        public static FLSliceResult c4db_getIndexes(C4Database* database, C4Error* outError) => Impl.c4db_getIndexes(database, outError);
        public static FLSliceResult c4db_getIndexesInfo(C4Database* database, C4Error* outError) => Impl.c4db_getIndexesInfo(database, outError);
        public static bool c4repl_isValidDatabaseName(FLSlice dbName) => Impl.c4repl_isValidDatabaseName(dbName);
        public static bool c4address_fromURL(FLSlice url, C4Address* address, FLSlice* dbName) => Impl.c4address_fromURL(url, address, dbName);
        public static FLSliceResult c4address_toURL(C4Address address) => Impl.c4address_toURL(address);
        public static bool c4db_setCookie(C4Database* db, FLSlice setCookieHeader, FLSlice fromHost, FLSlice fromPath, C4Error* outError) => Impl.c4db_setCookie(db, setCookieHeader, fromHost, fromPath, outError);
        public static FLSliceResult c4db_getCookies(C4Database* db, C4Address request, C4Error* error) => Impl.c4db_getCookies(db, request, error);
        public static void c4socket_closeRequested(C4Socket* socket, int status, FLSlice message) => Impl.c4socket_closeRequested(socket, status, message);
        public static void c4socket_completedWrite(C4Socket* socket, UIntPtr byteCount) => Impl.c4socket_completedWrite(socket, byteCount);
        public static void c4socket_received(C4Socket* socket, FLSlice data) => Impl.c4socket_received(socket, data);
        public static FLDoc* FLDoc_FromJSON(FLSlice json, FLError* outError) => Impl.FLDoc_FromJSON(json, outError);
        public static FLSlice FLDoc_GetData(FLDoc* x) => Impl.FLDoc_GetData(x);
        public static FLSliceResult FLDoc_GetAllocedData(FLDoc* x) => Impl.FLDoc_GetAllocedData(x);
        public static FLValue* FLValue_FromData(FLSlice data, FLTrust x) => Impl.FLValue_FromData(data, x);
        public static FLSliceResult FLData_ConvertJSON(FLSlice json, FLError* outError) => Impl.FLData_ConvertJSON(json, outError);
        public static FLSliceResult FLData_Dump(FLSlice data) => Impl.FLData_Dump(data);
        public static FLSliceResult FLValue_ToJSON(FLValue* value) => Impl.FLValue_ToJSON(value);
        public static FLSliceResult FLValue_ToJSON5(FLValue* v) => Impl.FLValue_ToJSON5(v);
        public static FLSliceResult FLValue_ToJSONX(FLValue* v, bool json5, bool canonicalForm) => Impl.FLValue_ToJSONX(v, json5, canonicalForm);
        public static FLSliceResult FLJSON5_ToJSON(FLSlice json5, FLError* error) => Impl.FLJSON5_ToJSON(json5, error);
        public static char* FLDumpData(FLSlice data) => Impl.FLDumpData(data);
        public static FLSlice FLValue_AsString(FLValue* value) => Impl.FLValue_AsString(value);
        public static FLSlice FLValue_AsData(FLValue* value) => Impl.FLValue_AsData(value);
        public static FLSliceResult FLValue_ToString(FLValue* value) => Impl.FLValue_ToString(value);
        public static void FLMutableArray_AppendString(FLMutableArray x, FLSlice str) => Impl.FLMutableArray_AppendString(x, str);
        public static void FLMutableArray_AppendData(FLMutableArray x, FLSlice slice) => Impl.FLMutableArray_AppendData(x, slice);
        public static void FLMutableArray_SetString(FLMutableArray x, uint index, FLSlice str) => Impl.FLMutableArray_SetString(x, index, str);
        public static void FLMutableArray_SetData(FLMutableArray x, uint index, FLSlice slice) => Impl.FLMutableArray_SetData(x, index, slice);
        public static FLValue* FLDict_Get(FLDict* dict, FLSlice keyString) => Impl.FLDict_Get(dict, keyString);
        public static FLSlice FLDictIterator_GetKeyString(FLDictIterator* i) => Impl.FLDictIterator_GetKeyString(i);
        public static FLDictKey FLDictKey_Init(FLSlice @string) => Impl.FLDictKey_Init(@string);
        public static FLSlice FLDictKey_GetString(FLDictKey* dictKey) => Impl.FLDictKey_GetString(dictKey);
        public static void FLMutableDict_SetNull(FLMutableDict x, FLSlice key) => Impl.FLMutableDict_SetNull(x, key);
        public static void FLMutableDict_SetBool(FLMutableDict x, FLSlice key, bool b) => Impl.FLMutableDict_SetBool(x, key, b);
        public static void FLMutableDict_SetInt(FLMutableDict x, FLSlice key, long l) => Impl.FLMutableDict_SetInt(x, key, l);
        public static void FLMutableDict_SetUInt(FLMutableDict x, FLSlice key, ulong u) => Impl.FLMutableDict_SetUInt(x, key, u);
        public static void FLMutableDict_SetFloat(FLMutableDict x, FLSlice key, float f) => Impl.FLMutableDict_SetFloat(x, key, f);
        public static void FLMutableDict_SetDouble(FLMutableDict x, FLSlice key, double d) => Impl.FLMutableDict_SetDouble(x, key, d);
        public static void FLMutableDict_SetString(FLMutableDict x, FLSlice key, FLSlice str) => Impl.FLMutableDict_SetString(x, key, str);
        public static void FLMutableDict_SetData(FLMutableDict x, FLSlice key, FLSlice slice) => Impl.FLMutableDict_SetData(x, key, slice);
        public static void FLMutableDict_SetValue(FLMutableDict x, FLSlice key, FLValue* value) => Impl.FLMutableDict_SetValue(x, key, value);
        public static void FLMutableDict_Remove(FLMutableDict x, FLSlice key) => Impl.FLMutableDict_Remove(x, key);
        public static FLMutableArray FLMutableDict_GetMutableArray(FLMutableDict x, FLSlice key) => Impl.FLMutableDict_GetMutableArray(x, key);
        public static FLMutableDict FLMutableDict_GetMutableDict(FLMutableDict x, FLSlice key) => Impl.FLMutableDict_GetMutableDict(x, key);
        public static FLSlice FLDeepIterator_GetKey(FLDeepIterator* x) => Impl.FLDeepIterator_GetKey(x);
        public static void FLDeepIterator_GetPath(FLDeepIterator* x, FLPathComponent** outPath, UIntPtr* outDepth) => Impl.FLDeepIterator_GetPath(x, outPath, outDepth);
        public static FLSliceResult FLDeepIterator_GetPathString(FLDeepIterator* x) => Impl.FLDeepIterator_GetPathString(x);
        public static FLSliceResult FLDeepIterator_GetJSONPointer(FLDeepIterator* x) => Impl.FLDeepIterator_GetJSONPointer(x);
        public static FLKeyPath* FLKeyPath_New(FLSlice specifier, FLError* error) => Impl.FLKeyPath_New(specifier, error);
        public static FLValue* FLKeyPath_EvalOnce(FLSlice specifier, FLValue* root, FLError* error) => Impl.FLKeyPath_EvalOnce(specifier, root, error);
        public static FLSharedKeys* FLSharedKeys_CreateFromStateData(FLSlice slice) => Impl.FLSharedKeys_CreateFromStateData(slice);
        public static FLSliceResult FLSharedKeys_GetStateData(FLSharedKeys* shared) => Impl.FLSharedKeys_GetStateData(shared);
        public static int FLSharedKeys_Encode(FLSharedKeys* shared, FLSlice str, bool add) => Impl.FLSharedKeys_Encode(shared, str, add);
        public static FLSlice FLSharedKeys_Decode(FLSharedKeys* shared, int key) => Impl.FLSharedKeys_Decode(shared, key);
        public static FLEncoder* FLEncoder_NewWithOptions(FLEncoderFormat format, UIntPtr reserveSize, bool uniqueStrings) => Impl.FLEncoder_NewWithOptions(format, reserveSize, uniqueStrings);
        public static void FLEncoder_Amend(FLEncoder* e, FLSlice @base, bool reuseStrings, bool externPointers) => Impl.FLEncoder_Amend(e, @base, reuseStrings, externPointers);
        public static FLSlice FLEncoder_GetBase(FLEncoder* encoder) => Impl.FLEncoder_GetBase(encoder);
        public static bool FLEncoder_WriteString(FLEncoder* encoder, FLSlice str) => Impl.FLEncoder_WriteString(encoder, str);
        public static bool FLEncoder_WriteData(FLEncoder* encoder, FLSlice slice) => Impl.FLEncoder_WriteData(encoder, slice);
        public static bool FLEncoder_WriteRaw(FLEncoder* encoder, FLSlice slice) => Impl.FLEncoder_WriteRaw(encoder, slice);
        public static bool FLEncoder_BeginArray(FLEncoder* encoder, UIntPtr reserveCount) => Impl.FLEncoder_BeginArray(encoder, reserveCount);
        public static bool FLEncoder_BeginDict(FLEncoder* encoder, UIntPtr reserveCount) => Impl.FLEncoder_BeginDict(encoder, reserveCount);
        public static bool FLEncoder_WriteKey(FLEncoder* encoder, FLSlice str) => Impl.FLEncoder_WriteKey(encoder, str);
        public static bool FLEncoder_ConvertJSON(FLEncoder* encoder, FLSlice json) => Impl.FLEncoder_ConvertJSON(encoder, json);
        public static FLSliceResult FLEncoder_Finish(FLEncoder* e, FLError* outError) => Impl.FLEncoder_Finish(e, outError);
        public static FLSliceResult FLCreateJSONDelta(FLValue* old, FLValue* nuu) => Impl.FLCreateJSONDelta(old, nuu);
        public static FLSliceResult FLApplyJSONDelta(FLValue* old, FLSlice jsonDelta, FLError* error) => Impl.FLApplyJSONDelta(old, jsonDelta, error);
    }
}
